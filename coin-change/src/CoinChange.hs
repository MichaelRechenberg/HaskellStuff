module CoinChange
    (
     coinChange, coinChangeMemo
    )
    where


import Data.List
import qualified Data.Map.Strict as Map
import Text.Printf


--Used for `trace` in debugging
import Debug.Trace

--coinChange initialAmt coins
--  initialAmt: The starting initial amount, must be a positive number > 0 or -1 is returned
--  coins: List of all the 'coins' (denominations of coins), all coins are unique values
--
--Returns the amount of possible combinations as a positive int (or -1 if an error occurred)
coinChange :: Int -> [Int] -> Int
coinChange initialAmt coins 
  | initialAmt <= 0 || coins == [] = -1
  | otherwise  = coinChangeR initialAmt coins



--coinChangeR initialAmt coins
--  initialAmt: The starting initial amount
--  coins: List of all the 'coins' (denominations of coins), all coins are unique values
--Returns the amount of possible combinations for splitting up the given 'initialAmt' using 'coins'
coinChangeR :: Int -> [Int] -> Int
coinChangeR initialAmt coins
  -- Invalid arguments
  | initialAmt < 0 || coins == [] = 0
  -- Found a solution!
  | initialAmt == 0 = 1
  -- Search subproblems
  | otherwise = coinUsed + coinNotUsed
  where 
    coinUsed = coinChangeR (initialAmt - head coins) coins
    coinNotUsed = coinChangeR initialAmt (tail coins)

--External driver for the memoized version of coin change
--
--coinChangeMemo initialAmt coins
--  initialAmt: The starting initial amount, must be a positive number > 0 or -1 is returned
--  coins: List of all the 'coins' (denominations of coins), all coins are unique values
--Returns the amount of possible combinations as a positive int (or -1 if an error occurred)
coinChangeMemo :: Int -> [Int] -> Int
coinChangeMemo initialAmt coins 
  | initialAmt <= 0 || coins == [] = -1
  | otherwise = fst $ coinChangeMemoR initialAmt coins Map.empty 


--(Memoized) recursive helper for coinChangeMemo
--
--coinChangeMemoR initialAmt coins cache 
--  initialAmt: The starting initial amount
--  coins: List of all the 'coins' (denominations of coins), all coins are unique values
--  cache: Map that contains the results of any subproblem we've already solved before.
--         The keys are strings generated by keyGen and the values are the number of total
--            combinations found for that subproblem (for that pair of initialAmt and coins)
--Returns: a tuple (totalCombs, cacheAfterCalculation)
coinChangeMemoR :: Int -> [Int] -> Map.Map String Int -> (Int, Map.Map String Int)
coinChangeMemoR initialAmt coins cache
  -- Invalid arguments
  | initialAmt < 0 || coins == [] = (0, cache)
  -- Found a solution!
  | initialAmt == 0 = (1, cache)
  -- Search subproblems
  | otherwise = finalResult
  where 
    key = keyGen initialAmt coins

    --Look to see if we've solved the problem already
    cachedResult = Map.lookup key cache 

    --Work we have to do if the problem wasn't already cached
    --  1) Count combinations for coin used
    --  2) Count combinations for coin NOT used
    --  3) Return the total combinations and the new cache
    --
    --Recall Haskell is lazy so these operations won't actually
    --  happen unless we need them to occur (i.e. the lookup failed)
  --
    --So we are more declaring what these variables mean in the mathematical
    --  sense rather than outlining steps to do
    coinUsedResults = coinChangeMemoR (initialAmt - head coins) coins cache
    coinUsedNumCombs = fst coinUsedResults 
    coinUsedResultsCache = snd coinUsedResults 
    coinNotUsedResults = coinChangeMemoR initialAmt (tail coins) coinUsedResultsCache
    coinNotUsedNumCombs = fst coinNotUsedResults 
    totalCombs = coinUsedNumCombs + coinNotUsedNumCombs
    newCache = Map.insert key totalCombs $ snd coinNotUsedResults
    workedResult = (totalCombs, newCache)

    finalResult = case cachedResult of
                    Just result -> (result, cache)
                    Nothing -> workedResult
                    


--Helper function to generate String key for the cache of coinChangeMemoR
--keyGen initialAmt coins 
--Returns: a String that is a suitable key for coinChangeMemoR's cache
keyGen :: Int -> [Int] -> String
keyGen initialAmt coins = printf "%d/%s" initialAmt (show coins)

