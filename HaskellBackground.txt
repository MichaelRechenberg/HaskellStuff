Haskell if purely functional (if you say x = 5, x cannot equal anything else on a later line)

Haskell has lazy evaluation
Haskell is statically typed (no Python ducktyping here)
  Haskell has type inference ( a = 5 + 4 --> Haskell knows a is a number)
Haskell is a compiled language
  GHC is a popular compiler
  Hugs is a Haskell REPL
Haskell scripts have a .hs file extension

Haskell has a mathematical feel to its notation
  list comprehensions look like set definitions in Latex


Append /usr/mrechenberg/.local/bin to PATH?


Stack is a cross platform development program for Haskell https://docs.haskellstack.org/en/stable/README/
  Package management
  GHC
  Building
  Testing
  Benchmarking

Stack is like SBT for Haskell


  stack new name_of_project
  cd name-of-project
  stack setup
  stack build
  stack exec name-of-project-exe

  Project Structure:
    edit files in src/

  Install packages with 
    stack install

  Start REPL
    stack ghci
    
      OR

    stack repl

    :l some-file.hs
      loads a file into REPL so you can use functions within that file

    :r
      reload the current script

    :t some-var
      display the type of some-var

    let
      define a variable in REPL-land (think if it like in a proof)

      let x = 3
        is as if in a script you wrote
      x = 3

  If you add new modules you'll have to modify the .cabal file
    in order for stack to see that module

  library
    hs-source-dirs:      src
    <<<<<<<
    exposed-modules:     Lib
    >>>>>>>
    exposed-modules:     Lib, Sorts
    build-depends:       base >= 4.7 && < 5
    default-language:    Haskell2010


